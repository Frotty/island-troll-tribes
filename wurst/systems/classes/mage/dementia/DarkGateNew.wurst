package DarkGateNew



import RegisterEvents
import HashMap
import LinkedList
import ClosureTimers
import Orders

@configurable constant int ABILITY_ID = 'A076'
@configurable constant real GROW_DURATION = 10
@configurable constant real MINIMUM_GROW_DURATION = 1.5
@configurable constant real DURATION = 40
@configurable constant int ORB_COUNT = 7
@configurable constant real ORB_LOOP_INTERVAL = 0.03125
@configurable constant real ORB_ANGULARSPEED_SUMMON = 80 
@configurable constant real ORB_ANGULARSPEED_ACTIVE = 10 
@configurable constant real SPELLCAST_INTERVAL_FASTEST = 1.5
@configurable constant real SPELLCAST_INTERVAL_START = 2.5
@configurable constant real PORTAL_GROWSPEED = 100 
@configurable constant string INITIAL_EFFECT_PATH = "Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"
@configurable constant string TRAIL_EFFECT_PATH = "Abilities\\Weapons\\AvengerMissile\\AvengerMissile.mdl"
@configurable constant string ORB_EFFECT_PATH = "Objects\\InventoryItems\\CrystalShard\\CrystalShard.mdl" 

let darkPortalInstances = new HashMap<unit, DarkPortalInstance>()
let spellList = new LinkedList<orbSpell>()

class orbSpell
    int spellId
    int orderId
    construct(int spellId, int orderId)

class PortalOrb
    DarkPortalInstance instance
    effect orbFX = null
    effect trailFX = null
    vec3 pos

    construct (DarkPortalInstance portal, vec3 startPos)
        instance = portal
        pos = startPos
        orbFX = addEffect(ORB_EFFECT_PATH, startPos)
        orbFX.setTimeScale(0)
        trailFX = addEffect(TRAIL_EFFECT_PATH, startPos)

    function setPos(vec3 newpos)
        pos = newpos
        //Adjust orbs a little lower since the SFX looks like its higher
        orbFX.setPos(pos - vec3(0,0,75))
        trailFX.setPos(pos)

    function setFacing(angle facing)
        orbFX.setRoll(facing)

    ondestroy
        instance.orbs.remove(this)
        orbFX.destr()
        trailFX.destr()


class DarkPortalInstance
    angle orbAngle
    unit ownerUnit
    bool isChanneling
    real portalRadius
    real elapsedLifetime
    real channeledTime
    real lastSpellCastTimestamp
    real spellIntervalCurrent
    vec3 centerPos
    CallbackCounted portalActiveLoop = null
    CallbackCounted portalCreationLoop = null

    LinkedList<PortalOrb> orbs = new LinkedList<PortalOrb>()

    construct (unit caster, vec3 pos)
        ownerUnit = caster
        isChanneling = true
        portalRadius = 50
        centerPos = pos
        elapsedLifetime = 0
        channeledTime = 0
        lastSpellCastTimestamp = -9999
        orbAngle = angle(0)
        spellIntervalCurrent = SPELLCAST_INTERVAL_START
        startPortalCreation()

    function startPortalCreation()
        for i = 1 to ORB_COUNT
            orbs.push(new PortalOrb(this, centerPos))
        
        portalCreationLoop = doPeriodicallyTimed(ORB_LOOP_INTERVAL, GROW_DURATION) portalGrowLoop ->
            if not isChanneling or portalGrowLoop.isLast()
                portalGrowLoop.stop()
                this.startPortalLoop()
            else
                portalRadius += ORB_LOOP_INTERVAL * PORTAL_GROWSPEED
                orbAngle = angle(orbAngle.radians() + ORB_LOOP_INTERVAL * ORB_ANGULARSPEED_SUMMON * DEGTORAD)
            
                //Avoid creating vision on every loop cycle
                if (portalGrowLoop.getCount() mod 30 == 0)
                    var vis = createVision(ownerUnit.getOwner(), centerPos.toVec2(), portalRadius+100, true)
                    vis.start()
                    doAfter(DURATION + GROW_DURATION - elapsedLifetime) ->
                        vis.destr()
                
                
                //Depending on how long portal was channeled, increase spellcasting rate
                spellIntervalCurrent = SPELLCAST_INTERVAL_START - (SPELLCAST_INTERVAL_START - SPELLCAST_INTERVAL_FASTEST) * (elapsedLifetime/GROW_DURATION)
                elapsedLifetime += ORB_LOOP_INTERVAL
                channeledTime += ORB_LOOP_INTERVAL
                updateOrbAngles()

    function randomOrbCastSpell()
        var orb = this.orbs.get( GetRandomInt(0, orbs.size() - 1))
        var randomSpell = spellList.get( GetRandomInt(0, spellList.size() - 1))

    function updateOrbAngles()
        //Calculate orb angles and set it
        angle orbOffset = angle((360 / orbs.size())*DEGTORAD)
        int i = 0
        for o in orbs
            angle indexOrbAngle = orbAngle + orbOffset * i.toReal()
            o.setPos(centerPos.offset2d(indexOrbAngle, portalRadius))
            o.setFacing(o.pos.angleTo2d(centerPos))
            i = i + 1

    function startPortalLoop()
        if channeledTime < MINIMUM_GROW_DURATION
            destroy this
        else
            portalActiveLoop = doPeriodicallyTimed(ORB_LOOP_INTERVAL, DURATION) portalLoop ->
                //Check for destruction conditions first before accessing any objects
                if (portalLoop.isLast())
                    destroy this
                else    
                    
                    orbAngle = angle(orbAngle.radians() + ORB_LOOP_INTERVAL * ORB_ANGULARSPEED_ACTIVE * DEGTORAD)
                    updateOrbAngles()
                    if (this.elapsedLifetime - this.lastSpellCastTimestamp >= this.spellIntervalCurrent)
                        this.lastSpellCastTimestamp = this.elapsedLifetime
                        randomOrbCastSpell()
                    elapsedLifetime += ORB_LOOP_INTERVAL

    ondestroy
        orbs.forEach(o -> destroy o)
        destroy orbs

        if darkPortalInstances.has(ownerUnit)
            if (darkPortalInstances.get(ownerUnit) == this) 
                darkPortalInstances.remove(ownerUnit)

function onCast()
    var caster = GetSpellAbilityUnit()

    //Destroy previous instance
    if darkPortalInstances.has(caster)
        var prev_instance = darkPortalInstances.get(caster)
        if prev_instance.portalActiveLoop != null
            prev_instance.portalActiveLoop.stop()
        if prev_instance.portalActiveLoop != null
            prev_instance.portalActiveLoop.stop()
    
    //Spawn the portal, a bit higher than the caster on Z axis
    darkPortalInstances.put(caster, new DarkPortalInstance(caster, caster.getPos3Real() + vec3(0, 0, 50)))

function onEndCast()
    if GetSpellAbilityId() == ABILITY_ID
        var caster = GetSpellAbilityUnit()
        var instance = darkPortalInstances.get(caster)
        instance.isChanneling = false

function createSpellList()
    spellList.push(new orbSpell('A038', Orders.carrionswarm) )
    spellList.push(new orbSpell('A01K', Orders.shadowstrike) )
    spellList.push(new orbSpell('A02A', Orders.frostnova) )
    spellList.push(new orbSpell('A028', Orders.impale) )
    spellList.push(new orbSpell('A065', Orders.manaburn) )
    spellList.push(new orbSpell('A02V', Orders.creepthunderbolt) )
    spellList.push(new orbSpell('ACfl', Orders.forkedlightning) )
    spellList.push(new orbSpell('ACtb', Orders.creepthunderbolt) )
    spellList.push(new orbSpell('A020', Orders.frostnova) )
    spellList.push(new orbSpell('A01X', Orders.chainlightning) )

init
    registerSpellEffectEvent(ABILITY_ID, () -> onCast())
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEndCast())