package MeatSystem
import ItemObjEditing
import ClosureEvents
import LinkedList
import MapBounds
import HashMap
import ClosureTimers
import AbilityObjEditing

let ITEM_RAW_MEAT = 'IRAW'
let MAX_MEAT_COUNT = 8
let MEAT_POS_OFFSET = vec3(-45, 0, 50)
let ABILITY_ID_DROPMEAT = 'XDRP'
IterableMap<unit, MeatInventory> instances = new IterableMap<unit, MeatInventory>()

@compiletime function createRawMeatObject()
    new ItemDefinition(ITEM_RAW_MEAT, 'shrs')
        ..setModelUsed("Heart.mdx")
        ..setAbilities("")
        ..setInterfaceIcon("ReplaceableTextures\\CommandButtons\\BTNCorpseExplode.blp")
        ..setScalingValue(0.45)
        ..setClassification("Miscellaneous")
        ..setGoldCost(0)
        ..setLumberCost(0)
        ..setDroppedWhenCarrierDies(true)
        ..setLevel(1)
        ..setNumberofCharges(1)
        ..setName("Raw Meat")
        ..setDescription("Raw meat that needs to be cooked at a campfire")
        ..setTooltipBasic("Trade for raw meat")
        ..setTooltipExtended("Raw meat that needs to be cooked at a campfire")

@compiletime function createDropMeatAbility()
    new AbilityDefinitionIllidanChannel(ABILITY_ID_DROPMEAT)
        ..setTargetType(1, 0)
        ..setAnimationNames("")
        ..setArtCaster("")
        ..setArtEffect("")
        ..setArtTarget("")
        ..setArtSpecial("")
        ..setButtonPositionNormalX(0)
        ..setButtonPositionNormalY(2)
        ..setButtonPositionResearchX(0)
        ..setButtonPositionResearchY(2)
        ..setIconNormal("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconResearch("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconTurnOff("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setHeroAbility(false)
        ..setItemAbility(false)
        ..setLevels(3)
        ..setHotkeyNormal("C")
        ..setName("Drop Raw Meat")
        ..setDisableOtherAbilities(1, false)
        ..setTooltipNormal(1, "|c00ffcc00C|r - Drop Raw Meat")
        ..setTooltipNormalExtended(1, "Drops all carried raw meat")
        ..presetBaseOrderID(lvl -> "unburrow")
        ..setOrderStringActivate("unburrow")
        ..setOrderStringUseTurnOn("unburrow")
        ..presetOptions(lvl -> 1)
        ..presetCooldown(lvl -> 0)
        ..presetManaCost(lvl -> 0)
        ..presetFollowThroughTime(lvl -> 0)

class MeatInventory
    unit owner
    LinkedList<item> meats
    texttag floatingText

    construct(unit owner)
        this.owner = owner
        this.meats = new LinkedList<item>()
        this.floatingText = null

    function emptyToGround()
        let ownerPos = owner.getPos()
        for meat in meats
            meat.setVisible(true)
            meat.setPos(ownerPos)
            meats.remove(meat)

    function onPickupMeat(item meat)
        owner.removeItem(meat)
        if canPickupMeat()
            meat.setVisible(false)
            meat.setPos(boundMax)
            meats.add(meat)

    function onOwnerDeath()
        this.emptyToGround()

    function canPickupMeat() returns bool
        return meats.size() < MAX_MEAT_COUNT

    function setOwner(unit owner)
        this.owner = owner

    function updateFloatingText()
        //Draw ascii-style text to show the meats carried by unit
        if (not owner.isAlive() or owner.isHidden()) and this.floatingText != null
            this.floatingText.destr()
            this.floatingText = null
            return

        if this.floatingText == null
            let text = getMeatFloatText()
            this.floatingText = createTTEx(owner.getPos().withTerrainZ() + MEAT_POS_OFFSET, text, 5, colorA(255,0,0,255))
                ..setVisibility(localPlayer == this.owner.getOwner())
        else
            this.floatingText.setText(getMeatFloatText(), 5)
            this.floatingText.setPos(owner.getPos().withTerrainZ() + MEAT_POS_OFFSET)

    private function getMeatFloatText() returns string
        string txt = "Raw meat: " + meats.getSize().toString()
        /*
        for m in meats
            txt = txt + "||||||||||||||| "
        */
        return txt

    ondestroy
        if this.floatingText != null
            this.floatingText.destr()
        destroy meats

function onTrollMeatPickup(unit troll, item meat)
    //Call meatpickup func for instance, or create one first and then call
    if instances.has(troll)
        instances.get(troll).onPickupMeat(meat)
    else
        let instance = new MeatInventory(troll)
        instances.put(troll, instance)
        instance.onPickupMeat(meat)

init
    EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) ->
        let maybeMeat = GetManipulatedItem()
        let u = GetTriggerUnit()
        if maybeMeat.getTypeId() == ITEM_RAW_MEAT
            if udg_trolls.contains(u)
                onTrollMeatPickup(u, maybeMeat)
            else
                //Disable meat pickup for any non-troll
                u.removeItem(maybeMeat)

    EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
        let dying = GetTriggerUnit()
        if instances.has(dying)
            instances.get(dying).onOwnerDeath()

    registerSpellEffectEvent(ABILITY_ID_DROPMEAT) ->
        let caster = GetSpellAbilityUnit()
        if instances.has(caster)
            instances.get(caster).emptyToGround()

    doPeriodically(ANIMATION_PERIOD) updaterLoop ->
        for k in instances
            instances.get(k).updateFloatingText()
