package MeatSystem
import ItemObjEditing
import ClosureEvents
import LinkedList
import MapBounds
import HashMap
import ClosureTimers
import AbilityObjEditing
import Orders
import SimError

let ITEM_RAW_MEAT = 'IRAW'
let MAX_MEAT_COUNT = 8
let MEAT_POS_OFFSET = vec3(-45, 0, 50)
let ABILITY_ID_DROPMEAT = 'XDRP'
let PICK_UP_RANGE = 150.0
IterableMap<unit, MeatInventory> instances = new IterableMap<unit, MeatInventory>()

@compiletime function createRawMeatObject()
    new ItemDefinition(ITEM_RAW_MEAT, 'shrs')
        ..setModelUsed("Heart.mdx")
        ..setAbilities("")
        ..setInterfaceIcon("ReplaceableTextures\\CommandButtons\\BTNCorpseExplode.blp")
        ..setScalingValue(0.55)
        ..setClassification("Miscellaneous")
        ..setGoldCost(0)
        ..setLumberCost(0)
        ..setDroppedWhenCarrierDies(true)
        ..setLevel(1)
        ..setNumberofCharges(1)
        ..setName("Raw Meat")
        ..setDescription("Raw meat that needs to be cooked at a campfire")
        ..setTooltipBasic("Trade for raw meat")
        ..setTooltipExtended("Raw meat that needs to be cooked at a campfire")

@compiletime function createDropMeatAbility()
    new AbilityDefinitionIllidanChannel(ABILITY_ID_DROPMEAT)
        ..setTargetType(1, 0)
        ..setAnimationNames("")
        ..setArtCaster("")
        ..setArtEffect("")
        ..setArtTarget("")
        ..setArtSpecial("")
        ..setButtonPositionNormalX(0)
        ..setButtonPositionNormalY(2)
        ..setButtonPositionResearchX(0)
        ..setButtonPositionResearchY(2)
        ..setIconNormal("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconResearch("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconTurnOff("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setHeroAbility(false)
        ..setItemAbility(false)
        ..setLevels(3)
        ..setHotkeyNormal("C")
        ..setName("Drop Raw Meat")
        ..setDisableOtherAbilities(1, false)
        ..setTooltipNormal(1, "|c00ffcc00C|r - Drop Raw Meat")
        ..setTooltipNormalExtended(1, "Drops all carried raw meat")
        ..presetBaseOrderID(lvl -> "unburrow")
        ..setOrderStringActivate("unburrow")
        ..setOrderStringUseTurnOn("unburrow")
        ..presetOptions(lvl -> 1)
        ..presetCooldown(lvl -> 0)
        ..presetManaCost(lvl -> 0)
        ..presetFollowThroughTime(lvl -> 0)

class MeatInventory
    player ownerPlayer
    unit ownerUnit
    LinkedList<item> carriedMeat
    texttag meatAmountText
    CallbackPeriodic smartPickupCallback
    item smartPickupTarget

    construct(unit owner)
        this.ownerUnit = owner
        this.ownerPlayer = ownerUnit.getOwner()
        this.carriedMeat = new LinkedList<item>()
        this.meatAmountText = null

    function emptyToGround()
        let ownerPos = ownerUnit.getPos()
        for meat in carriedMeat
            meat.setVisible(true)
            meat.setPos(ownerPos)
            carriedMeat.remove(meat)

    function tryPickupMeat(item meat)
        ownerUnit.removeItem(meat)
        if canPickupMeat()
            meat.setPos(boundMax)
            meat.setVisible(false)
            carriedMeat.add(meat)
        else
            simError(ownerPlayer, "Raw meat capacity full!")

    function onOwnerDeath()
        this.emptyToGround()

    function canPickupMeat() returns bool
        return carriedMeat.size() < MAX_MEAT_COUNT

    function setOwner(unit owner)
        this.ownerUnit = owner

    function onSmartPickupMeat(item meat)
        ownerUnit.issuePointOrderById(Orders.move, meat.getPos())
        this.smartPickupTarget = meat

        //Remove old callback if it exists
        if this.smartPickupCallback != null
            destroy this.smartPickupCallback
            this.smartPickupCallback = null

        //Start polling for when we reach the pickup target
        this.smartPickupCallback = doPeriodically(ANIMATION_PERIOD) cb ->
            let collisionSize = ownerUnit.getCollisionSize()
            let rangeSq = (PICK_UP_RANGE + collisionSize) * (PICK_UP_RANGE + collisionSize)
            //See if meat is gone already
            if not this.smartPickupTarget.isPickupable() or ownerUnit.getCurrentOrder() != Orders.move or not ownerUnit.isAlive()
                if ownerUnit.isAlive()
                    //Double checking that unit is alive before ordering
                    ownerUnit.issueImmediateOrderById(Orders.stop)
                destroy this.smartPickupCallback
                this.smartPickupCallback = null
            else if ownerUnit.getPos().distanceToSq(this.smartPickupTarget.getPos()) <= rangeSq
                //Otherwise, if in range, pick up meat
                this.tryPickupMeat(this.smartPickupTarget)
                ownerUnit.issueImmediateOrderById(Orders.stop)
                destroy this.smartPickupCallback
                this.smartPickupCallback = null

    function updateDisplays()
        updateFloatingText()
        updateFoodResource()

    private function updateFloatingText()
        //Draw ascii-style text to show the meats carried by unit
        if (not ownerUnit.isAlive() or ownerUnit.isHidden()) and this.meatAmountText != null
            this.meatAmountText.destr()
            this.meatAmountText = null
            return

        //Create new text if none exists
        if this.meatAmountText == null
            let text = getMeatFloatText()
            this.meatAmountText = createTTEx(ownerUnit.getPos().withTerrainZ() + MEAT_POS_OFFSET, text, 7, colorA(255,0,0,255))
                ..setVisibility(localPlayer == this.ownerPlayer)
        else
            //Otherwise update pos and text for existing text
            this.meatAmountText.setText(getMeatFloatText(), 7)
            this.meatAmountText.setPos(ownerUnit.getPos().withTerrainZ() + MEAT_POS_OFFSET)

    private function updateFoodResource()
        SetPlayerState(ownerPlayer, PLAYER_STATE_RESOURCE_FOOD_USED, carriedMeat.size())
        SetPlayerState(ownerPlayer, PLAYER_STATE_RESOURCE_FOOD_CAP, MAX_MEAT_COUNT)

    private function getMeatFloatText() returns string
        //Generate floating text to draw on meat carrier unit
        let size = carriedMeat.size()
        if size == 0
            return ""
        else
            return "Raw meat: " + size.toString()
        /*
        string txt = ""
        for m in meats
            txt = txt + "||||||||||||||| "
        return txt
        */

    ondestroy
        if this.smartPickupCallback != null
            destroy this.smartPickupCallback
        if this.meatAmountText != null
            this.meatAmountText.destr()
        destroy carriedMeat

function onTrollMeatPickup(unit troll, item meat)
    //Call meatpickup func for instance, or create one first and then call
    if instances.has(troll)
        instances.get(troll).tryPickupMeat(meat)
    else
        let instance = new MeatInventory(troll)
        instances.put(troll, instance)
        instance.tryPickupMeat(meat)

function onTargetOrder()
    let order = GetIssuedOrderId()
    let u = GetOrderedUnit()
    if order != Orders.smart
        return

    let target = GetOrderTargetItem()

    if target != null and target.getTypeId() == ITEM_RAW_MEAT and u.isInventoryFull() and udg_trolls.contains(u)
        if instances.has(u)
            let instance = instances.get(u)
            let meatCount = instance.carriedMeat.size()
            if meatCount < MAX_MEAT_COUNT
                instance.onSmartPickupMeat(target)
        else
            let instance = new MeatInventory(u)
            instances.put(u, instance)
            instance.onSmartPickupMeat(target)

init
    EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) ->
        let maybeMeat = GetManipulatedItem()
        let u = GetTriggerUnit()
        if maybeMeat.getTypeId() == ITEM_RAW_MEAT
            if udg_trolls.contains(u)
                onTrollMeatPickup(u, maybeMeat)
            else
                //Disable meat pickup for any non-troll
                u.removeItem(maybeMeat)

    EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
        let dying = GetTriggerUnit()
        if instances.has(dying)
            instances.get(dying).onOwnerDeath()

    EventListener.add(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
        onTargetOrder()

    registerSpellEffectEvent(ABILITY_ID_DROPMEAT) ->
        let caster = GetSpellAbilityUnit()
        if instances.has(caster)
            instances.get(caster).emptyToGround()

    doPeriodically(ANIMATION_PERIOD) updaterLoop ->
        for k in instances
            instances.get(k).updateDisplays()

    for i = 0 to bj_MAX_PLAYER_SLOTS-1
        SetPlayerState(players[i], PLAYER_STATE_RESOURCE_FOOD_USED, 0)
        SetPlayerState(players[i], PLAYER_STATE_RESOURCE_FOOD_CAP, MAX_MEAT_COUNT)
