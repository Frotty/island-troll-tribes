package MeatSystem
import ItemObjEditing
import ClosureEvents
import LinkedList
import MapBounds
import HashMap
import ClosureTimers
import AbilityObjEditing
import Orders
import SimError
import ID
import ClosuresForItems

let ITEM_RAW_MEAT = 'IRAW'
let MAX_MEAT_COUNT = 8
let MEAT_POS_OFFSET = vec3(-45, 0, 50)
let ABILITY_ID_DROPMEAT = 'XDRP'
let ABILITY_ID_PICKUPMEAT = 'XMPU'
let SMOOTH_PICKUP_RANGE = 150.0
let AOE_PICKUP_RADIUS = 200.
public IterableMap<unit, MeatInventory> meatInventoryInstances = new IterableMap<unit, MeatInventory>()

@compiletime function createRawMeatObject()
    new ItemDefinition(ITEM_RAW_MEAT, 'shrs')
        ..setModelUsed("Heart.mdx")
        ..setAbilities("")
        ..setInterfaceIcon("ReplaceableTextures\\CommandButtons\\BTNCorpseExplode.blp")
        ..setScalingValue(0.6)
        ..setClassification("Miscellaneous")
        ..setGoldCost(0)
        ..setLumberCost(0)
        ..setDroppedWhenCarrierDies(true)
        ..setLevel(1)
        ..setNumberofCharges(1)
        ..setName("Raw Meat")
        ..setDescription("Raw meat that needs to be cooked at a campfire")
        ..setTooltipBasic("Trade for raw meat")
        ..setTooltipExtended("Raw meat that needs to be cooked at a campfire")

@compiletime function createDropMeatAbility()
    new AbilityDefinitionIllidanChannel(ABILITY_ID_DROPMEAT)
        ..setTargetType(1, 0)
        ..setAnimationNames("")
        ..setArtCaster("")
        ..setArtEffect("")
        ..setArtTarget("")
        ..setArtSpecial("")
        ..setButtonPositionNormalX(0)
        ..setButtonPositionNormalY(2)
        ..setButtonPositionResearchX(0)
        ..setButtonPositionResearchY(2)
        ..setIconNormal("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconResearch("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconTurnOff("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setHeroAbility(false)
        ..setItemAbility(false)
        ..setLevels(3)
        ..setHotkeyNormal("C")
        ..setName("Drop Raw Meat")
        ..setDisableOtherAbilities(1, false)
        ..setTooltipNormal(1, "|c00ffcc00C|r - Drop Raw Meat")
        ..setTooltipNormalExtended(1, "Drops all carried raw meat")
        ..presetBaseOrderID(lvl -> "unburrow")
        ..setOrderStringActivate("unburrow")
        ..setOrderStringUseTurnOn("unburrow")
        ..presetOptions(lvl -> 1)
        ..presetCooldown(lvl -> 0)
        ..presetManaCost(lvl -> 0)
        ..presetFollowThroughTime(lvl -> 0)

class MeatInventory
    player ownerPlayer
    unit ownerUnit
    LinkedList<item> carriedMeat
    texttag meatAmountText
    CallbackPeriodic smartPickupCallback
    item smartPickupTarget

    construct(unit owner)
        this.ownerUnit = owner
        this.ownerPlayer = ownerUnit.getOwner()
        this.carriedMeat = new LinkedList<item>()
        this.meatAmountText = null
        updateFoodResource()

    function emptyToGround()
        let ownerPos = ownerUnit.getPos()
        for meat in carriedMeat
            meat.setVisible(true)
            meat.setPos(ownerPos)
            carriedMeat.remove(meat)
        updateFoodResource()

    function tryPickupMeat(item meat)
        ownerUnit.removeItem(meat)
        if canPickupMeat()
            meat.setPos(boundMax)
            meat.setVisible(false)
            carriedMeat.add(meat)
            updateFoodResource()
        else
            simError(ownerPlayer, "Raw meat capacity full!")

    function onOwnerDeath()
        this.emptyToGround()

    function canPickupMeat() returns bool
        return carriedMeat.size() < MAX_MEAT_COUNT

    function transferMeatInventoryToUnit(unit newOwner)
        meatInventoryInstances.remove(this.ownerUnit)
        this.ownerUnit = newOwner
        if meatInventoryInstances.has(newOwner)
            destroy meatInventoryInstances.getAndRemove(newOwner)
        meatInventoryInstances.put(newOwner, this)

    function onSmartPickupMeat(item meat)
        ownerUnit.issuePointOrderById(Orders.move, meat.getPos())
        this.smartPickupTarget = meat

        //Remove old callback if it exists
        if this.smartPickupCallback != null
            destroy this.smartPickupCallback
            this.smartPickupCallback = null

        //Start polling for when we reach the pickup target
        this.smartPickupCallback = doPeriodically(ANIMATION_PERIOD) cb ->
            let collisionSize = ownerUnit.getCollisionSize()
            let rangeSq = (SMOOTH_PICKUP_RANGE + collisionSize) * (SMOOTH_PICKUP_RANGE + collisionSize)
            //See if meat is gone already
            if not this.smartPickupTarget.isPickupable() or ownerUnit.getCurrentOrder() != Orders.move or not ownerUnit.isAlive()
                if ownerUnit.isAlive()
                    //Double checking that unit is alive before ordering
                    ownerUnit.issueImmediateOrderById(Orders.stop)
                destroy this.smartPickupCallback
                this.smartPickupCallback = null
            else if ownerUnit.getPos().distanceToSq(this.smartPickupTarget.getPos()) <= rangeSq
                //Otherwise, if in range, pick up meat
                this.tryPickupMeat(this.smartPickupTarget)
                ownerUnit.issueImmediateOrderById(Orders.stop)
                destroy this.smartPickupCallback
                this.smartPickupCallback = null

    function updateFloatingText()
        //Draw ascii-style text to show the meats carried by unit
        if (not ownerUnit.isAlive() or ownerUnit.isHidden()) and this.meatAmountText != null
            this.meatAmountText.destr()
            this.meatAmountText = null
            return

        //Create new text if none exists
        if this.meatAmountText == null
            let text = getMeatFloatText()
            this.meatAmountText = createTTEx(ownerUnit.getPos().withTerrainZ() + MEAT_POS_OFFSET, text, 7, colorA(255,0,0,255))
                ..setVisibility(localPlayer == this.ownerPlayer)
        else
            //Otherwise update pos and text for existing text
            this.meatAmountText.setText(getMeatFloatText(), 7)
            this.meatAmountText.setPos(ownerUnit.getPos().withTerrainZ() + MEAT_POS_OFFSET)

    private function updateFoodResource()
        SetPlayerState(ownerPlayer, PLAYER_STATE_RESOURCE_FOOD_USED, carriedMeat.size())
        SetPlayerState(ownerPlayer, PLAYER_STATE_RESOURCE_FOOD_CAP, MAX_MEAT_COUNT)

    private function getMeatFloatText() returns string
        //Generate floating text to draw on meat carrier unit
        let size = carriedMeat.size()
        if size == 0
            return ""
        else
            return "Raw meat: " + size.toString()
        /*
        string txt = ""
        for m in meats
            txt = txt + "||||||||||||||| "
        return txt
        */

    ondestroy
        emptyToGround()
        if this.smartPickupCallback != null
            destroy this.smartPickupCallback
        if this.meatAmountText != null
            this.meatAmountText.destr()
        if meatInventoryInstances.has(this.ownerUnit)
            meatInventoryInstances.remove(this.ownerUnit)
        destroy carriedMeat

function tryPickupMeat(unit u, item meat)
    //Call meatpickup func for instance, or create one first and then call
    if meatInventoryInstances.has(u)
        meatInventoryInstances.get(u).tryPickupMeat(meat)
    else
        let instance = new MeatInventory(u)
        meatInventoryInstances.put(u, instance)
        instance.tryPickupMeat(meat)

function tryPickupMeatArea(unit u)
    forItemsInRect(u.getPos().withRadiusRect(AOE_PICKUP_RADIUS)) maybeMeat ->
        if maybeMeat.getTypeId() == ITEM_RAW_MEAT
            tryPickupMeat(u, maybeMeat)

function onTargetOrder()
    let order = GetIssuedOrderId()
    let u = GetOrderedUnit()
    if order != Orders.smart
        return

    let target = GetOrderTargetItem()

    if target != null and target.getTypeId() == ITEM_RAW_MEAT and u.isInventoryFull() and udg_trolls.contains(u)
        if meatInventoryInstances.has(u)
            let instance = meatInventoryInstances.get(u)
            let meatCount = instance.carriedMeat.size()
            if meatCount < MAX_MEAT_COUNT
                instance.onSmartPickupMeat(target)
        else
            let instance = new MeatInventory(u)
            meatInventoryInstances.put(u, instance)
            instance.onSmartPickupMeat(target)

function isUnitMeatCarrier(unit u) returns bool
    return udg_trolls.contains(u) or u.getTypeId() == UNIT_ENSNARE_TRAP

init
    EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) ->
        let maybeMeat = GetManipulatedItem()
        let u = GetTriggerUnit()
        if maybeMeat.getTypeId() == ITEM_RAW_MEAT
            if isUnitMeatCarrier(u)
                tryPickupMeat(u, maybeMeat)
            else
                //Disable meat pickup for any non-troll
                u.removeItem(maybeMeat)

    EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
        let dying = GetTriggerUnit()
        if meatInventoryInstances.has(dying)
            meatInventoryInstances.get(dying).onOwnerDeath()

    EventListener.add(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
        onTargetOrder()

    registerSpellEffectEvent(ABILITY_ID_DROPMEAT) ->
        let caster = GetSpellAbilityUnit()
        if meatInventoryInstances.has(caster)
            meatInventoryInstances.get(caster).emptyToGround()

    registerSpellEffectEvent(ABILITY_ID_PICKUPMEAT) ->
        let caster = GetSpellAbilityUnit()
        if isUnitMeatCarrier(caster)
            tryPickupMeatArea(caster)

    for i = 0 to bj_MAX_PLAYER_SLOTS-1
        SetPlayerState(players[i], PLAYER_STATE_RESOURCE_FOOD_USED, 0)
        SetPlayerState(players[i], PLAYER_STATE_RESOURCE_FOOD_CAP, MAX_MEAT_COUNT)
