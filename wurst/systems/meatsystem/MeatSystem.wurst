package MeatSystem
import ItemObjEditing
import ClosureEvents
import LinkedList
import MapBounds
import HashMap
import ClosureTimers
import AbilityObjEditing
import Orders

let ITEM_RAW_MEAT = 'IRAW'
let MAX_MEAT_COUNT = 8
let MEAT_POS_OFFSET = vec3(-45, 0, 50)
let ABILITY_ID_DROPMEAT = 'XDRP'
let PICK_UP_RANGE = 150.0
IterableMap<unit, MeatInventory> instances = new IterableMap<unit, MeatInventory>()

@compiletime function createRawMeatObject()
    new ItemDefinition(ITEM_RAW_MEAT, 'shrs')
        ..setModelUsed("Heart.mdx")
        ..setAbilities("")
        ..setInterfaceIcon("ReplaceableTextures\\CommandButtons\\BTNCorpseExplode.blp")
        ..setScalingValue(0.55)
        ..setClassification("Miscellaneous")
        ..setGoldCost(0)
        ..setLumberCost(0)
        ..setDroppedWhenCarrierDies(true)
        ..setLevel(1)
        ..setNumberofCharges(1)
        ..setName("Raw Meat")
        ..setDescription("Raw meat that needs to be cooked at a campfire")
        ..setTooltipBasic("Trade for raw meat")
        ..setTooltipExtended("Raw meat that needs to be cooked at a campfire")

@compiletime function createDropMeatAbility()
    new AbilityDefinitionIllidanChannel(ABILITY_ID_DROPMEAT)
        ..setTargetType(1, 0)
        ..setAnimationNames("")
        ..setArtCaster("")
        ..setArtEffect("")
        ..setArtTarget("")
        ..setArtSpecial("")
        ..setButtonPositionNormalX(0)
        ..setButtonPositionNormalY(2)
        ..setButtonPositionResearchX(0)
        ..setButtonPositionResearchY(2)
        ..setIconNormal("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconResearch("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setIconTurnOff("ReplaceableTextures\\CommandButtons\\BTNUnLoad.blp")
        ..setHeroAbility(false)
        ..setItemAbility(false)
        ..setLevels(3)
        ..setHotkeyNormal("C")
        ..setName("Drop Raw Meat")
        ..setDisableOtherAbilities(1, false)
        ..setTooltipNormal(1, "|c00ffcc00C|r - Drop Raw Meat")
        ..setTooltipNormalExtended(1, "Drops all carried raw meat")
        ..presetBaseOrderID(lvl -> "unburrow")
        ..setOrderStringActivate("unburrow")
        ..setOrderStringUseTurnOn("unburrow")
        ..presetOptions(lvl -> 1)
        ..presetCooldown(lvl -> 0)
        ..presetManaCost(lvl -> 0)
        ..presetFollowThroughTime(lvl -> 0)

class MeatInventory
    unit owner
    LinkedList<item> meats
    texttag floatingText
    CallbackPeriodic smartPickupCallback
    item smartPickupTarget

    construct(unit owner)
        this.owner = owner
        this.meats = new LinkedList<item>()
        this.floatingText = null

    function emptyToGround()
        let ownerPos = owner.getPos()
        for meat in meats
            meat.setVisible(true)
            meat.setPos(ownerPos)
            meats.remove(meat)

    function tryPickupMeat(item meat)
        owner.removeItem(meat)
        if canPickupMeat()
            meat.setVisible(false)
            meat.setPos(boundMax)
            meats.add(meat)

    function onOwnerDeath()
        this.emptyToGround()

    function canPickupMeat() returns bool
        return meats.size() < MAX_MEAT_COUNT

    function setOwner(unit owner)
        this.owner = owner

    function onSmartPickupMeat(item meat)
        owner.issuePointOrderById(Orders.move, meat.getPos())
        this.smartPickupTarget = meat

        //Remove old callback if it exists
        if this.smartPickupCallback != null
            destroy this.smartPickupCallback
            this.smartPickupCallback = null

        this.smartPickupCallback = doPeriodically(ANIMATION_PERIOD) cb ->
            let collisionSize = owner.getCollisionSize()
            let rangeSq = (PICK_UP_RANGE + collisionSize) * (PICK_UP_RANGE + collisionSize)
            //See if meat is gone already
            if not this.smartPickupTarget.isPickupable() or owner.getCurrentOrder() != Orders.move or not owner.isAlive()
                if owner.isAlive()
                    //Double checking that unit is alive before ordering
                    owner.issueImmediateOrderById(Orders.stop)
                destroy this.smartPickupCallback
                this.smartPickupCallback = null
            else if owner.getPos().distanceToSq(this.smartPickupTarget.getPos()) <= rangeSq
                //Otherwise, if in range, pick up meat
                this.tryPickupMeat(this.smartPickupTarget)
                owner.issueImmediateOrderById(Orders.stop)
                destroy this.smartPickupCallback
                this.smartPickupCallback = null


    function updateFloatingText()
        //Draw ascii-style text to show the meats carried by unit
        if (not owner.isAlive() or owner.isHidden()) and this.floatingText != null
            this.floatingText.destr()
            this.floatingText = null
            return

        if this.floatingText == null
            let text = getMeatFloatText()
            this.floatingText = createTTEx(owner.getPos().withTerrainZ() + MEAT_POS_OFFSET, text, 7, colorA(255,0,0,255))
                ..setVisibility(localPlayer == this.owner.getOwner())
        else
            this.floatingText.setText(getMeatFloatText(), 7)
            this.floatingText.setPos(owner.getPos().withTerrainZ() + MEAT_POS_OFFSET)

    private function getMeatFloatText() returns string
        let size = meats.getSize().toString()
        if size == 0
            return ""
        else
            return "Raw meat: " + meats.getSize().toString()
        /*
        string txt = ""
        for m in meats
            txt = txt + "||||||||||||||| "
        return txt
        */

    ondestroy
        if this.floatingText != null
            this.floatingText.destr()
        destroy meats

function onTrollMeatPickup(unit troll, item meat)
    //Call meatpickup func for instance, or create one first and then call
    if instances.has(troll)
        instances.get(troll).tryPickupMeat(meat)
    else
        let instance = new MeatInventory(troll)
        instances.put(troll, instance)
        instance.tryPickupMeat(meat)

function onTargetOrder()
    let order = GetIssuedOrderId()
    let u = GetOrderedUnit()
    if order != Orders.smart
        return

    let target = GetOrderTargetItem()

    if target != null and target.getTypeId() == ITEM_RAW_MEAT and u.isInventoryFull() and udg_trolls.contains(u)
        if instances.has(u)
            let instance = instances.get(u)
            let meatCount = instance.meats.size()
            if meatCount < MAX_MEAT_COUNT
                instance.onSmartPickupMeat(target)
        else
            let instance = new MeatInventory(u)
            instances.put(u, instance)
            instance.onSmartPickupMeat(target)

init
    EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) ->
        let maybeMeat = GetManipulatedItem()
        let u = GetTriggerUnit()
        if maybeMeat.getTypeId() == ITEM_RAW_MEAT
            if udg_trolls.contains(u)
                onTrollMeatPickup(u, maybeMeat)
            else
                //Disable meat pickup for any non-troll
                u.removeItem(maybeMeat)

    EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
        let dying = GetTriggerUnit()
        if instances.has(dying)
            instances.get(dying).onOwnerDeath()

    EventListener.add(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
        onTargetOrder()

    registerSpellEffectEvent(ABILITY_ID_DROPMEAT) ->
        let caster = GetSpellAbilityUnit()
        if instances.has(caster)
            instances.get(caster).emptyToGround()

    doPeriodically(ANIMATION_PERIOD) updaterLoop ->
        for k in instances
            instances.get(k).updateFloatingText()
