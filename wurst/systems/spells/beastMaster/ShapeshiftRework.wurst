package ShapeshiftRework

import AbilityObjEditing
import ObjectIdGenerator
import ID
import ClosureEvents
import HashMap
import ObjectIds
import MeatSystem
import SimError

let FORM_IDS = [UNIT_SHAPESHIFTER_WOLF, UNIT_SHAPESHIFTER_BEAR, UNIT_SHAPESHIFTER_PANTHER, UNIT_SHAPESHIFTER_TIGER]
let FORM_MAP = new HashMap<string, integer>()
let ABILITY_IDS = [compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()),
compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()),
compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next()), compiletime(ABIL_ID_GEN.next())]
public let FORM_ABILITY_IDS = ['A0GD', 'A0GE', 'A0GF', 'A0GG']

@compiletime function formChanger()
    var i = 0
    for oldForm = 0 to 3
        for newForm = 0 to 3
            if newForm != oldForm
                new AbilityDefinitionBearform(ABILITY_IDS[i])
                ..setName(FORM_IDS[oldForm].toRawCode() + " to " + FORM_IDS[newForm].toRawCode())
                ..presetAlternateFormUnit(lvl -> FORM_IDS[oldForm].toRawCode())
                ..presetNormalFormUnit(lvl -> FORM_IDS[newForm].toRawCode())
                i++

function onCast(int newF)
    var caster = GetSpellAbilityUnit()
    var owner = caster.getOwner()
    var oldF = caster.getTypeId()
    var changeKey = oldF.toRawCode() + newF.toRawCode()
    if not FORM_MAP.has(changeKey)
        simError(owner, "You already are in that form.")
        return

    var changeAbility = FORM_MAP.get(changeKey)
    caster.makeAbilityPermanent('A00H', true)
    caster.makeAbilityPermanent('A0GN', true)
    caster.makeAbilityPermanent('A0GO', true)
    caster.makeAbilityPermanent('A0GP', true)
    caster.addAbility(changeAbility)
    caster.removeAbility(changeAbility)
    switch newF
        case FORM_IDS[0]
            owner.setAbilityAvailable(FORM_ABILITY_IDS[0], true)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[1], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[2], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[3], false)
        case FORM_IDS[1]
            owner.setAbilityAvailable(FORM_ABILITY_IDS[0], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[1], true)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[2], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[3], false)
        case FORM_IDS[2]
            owner.setAbilityAvailable(FORM_ABILITY_IDS[0], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[1], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[2], true)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[3], false)
        case FORM_IDS[3]
            owner.setAbilityAvailable(FORM_ABILITY_IDS[0], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[1], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[2], false)
            owner.setAbilityAvailable(FORM_ABILITY_IDS[3], true)

    if meatInventoryInstances.has(caster)
        meatInventoryInstances.get(caster).updateMeatAbilities()

init
    registerSpellEffectEvent('A00H', () -> onCast(FORM_IDS[0]))
    registerSpellEffectEvent('A0GN', () -> onCast(FORM_IDS[1]))
    registerSpellEffectEvent('A0GO', () -> onCast(FORM_IDS[2]))
    registerSpellEffectEvent('A0GP', () -> onCast(FORM_IDS[3]))
    var i = 0
    for oldForm = 0 to 3
        for newForm = 0 to 3
            if newForm != oldForm
                let abiKey = FORM_IDS[oldForm].toRawCode() + FORM_IDS[newForm].toRawCode()
                FORM_MAP.put(abiKey, ABILITY_IDS[i])
                i++
