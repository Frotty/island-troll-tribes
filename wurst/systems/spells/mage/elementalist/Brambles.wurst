package Brambles

import ClosureEvents
import ClosureTimers
import AbilityObjEditing
import OverCharge
import Assets
import ObjectIdGenerator
import ChatCommands
import GameConfig
import ClosureForGroups
import DummyCaster
import Orders
import DummyRecycler
import BuffObjEditing
import ObjectIds
import LinkedList
import MapBounds

constant let ABILITY_ID = 'ESBR'
constant let DUMMY_SLOW_SPELL_ID = compiletime(ABIL_ID_GEN.next())
constant let DUMMY_VISION_BONUS_ID = compiletime(ABIL_ID_GEN.next())
constant let DUMMY_SLOW_BUFF = compiletime(BUFF_ID_GEN.next())
constant let COOLDOWN = 40.
constant let MANACOST = 15
constant let RANGE = 700.
constant let DURATION = 6.
constant let EFFECT_AOE = 200.
constant let MS_SLOW = 0.75
constant let AS_SLOW = 0.40
constant let DAMAGE_PER_SECOND = 10
constant let ROOT_CREATION_PERIOD = 0.2
constant let UPDATE_LOOP_INTERVAL = 0.2
constant let SPELL_ICON = Icons.bTNEntanglingRoots
constant let ROOTS_EFFECT_PATH = "Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl"
constant let TOOLTIP_NORM = "|c00ffcc00S|r - Brambles"
constant let TOOLTIP_EXT = "Causes brambles to surface from underground in a straight line, slowing and damaging targets."

@compiletime function createDummyVisionAbility()
    new AbilityDefinitionSightBonus(DUMMY_VISION_BONUS_ID)
    ..setSightRangeBonus(1, 250)
    ..setHeroAbility(false)
    ..setItemAbility(false)
    ..setLevels(1)

@compiletime function createBuff()
    new BuffDefinition(DUMMY_SLOW_BUFF, 'Bfro')
    ..setTooltipNormal(1, "Brambles")
    ..setTooltipNormalExtended(1, "Slowed and damaged by brambles")
    ..setIcon(SPELL_ICON)
    ..setIconNormal(1, SPELL_ICON)
    ..setArtTarget(1, "")
    ..setArtSpecial(1, "")

@compiletime function createDummySlow()
    new AbilityDefinitionSlowCreep(DUMMY_SLOW_SPELL_ID)
    ..setLevels(1)
    ..setArtCaster("")
    ..setArtEffect("")
    ..setArtTarget("")
    ..setArtSpecial("")
    ..presetBuffs(lvl -> toRawCode(DUMMY_SLOW_BUFF))
    ..presetCastingTime(lvl -> 0)
    ..presetCastRange(lvl -> 9999)
    ..presetAreaofEffect(lvl -> 0)
    ..presetManaCost(lvl -> 0)
    ..presetCooldown(lvl -> 0)
    ..presetAttackSpeedFactor(lvl -> AS_SLOW)
    ..presetMovementSpeedFactor(lvl -> MS_SLOW)
    ..presetDurationHero(lvl -> UPDATE_LOOP_INTERVAL*5)
    ..presetDurationNormal(lvl -> UPDATE_LOOP_INTERVAL*5)
    ..setLevelSkipRequirement(0)
    ..setHeroAbility(false)
    ..setItemAbility(false)

@compiletime function createSpell()
    new AbilityDefinitionIllidanChannel(ABILITY_ID)
    ..setTargetType(1, 0)
    ..setAnimationNames("")
    ..setArtCaster("")
    ..setArtEffect("")
    ..setArtTarget("")
    ..setArtSpecial("")
    ..setButtonPositionNormalX(0)
    ..setButtonPositionNormalY(1)
    ..setButtonPositionResearchX(0)
    ..setButtonPositionResearchY(1)
    ..setIconNormal(SPELL_ICON)
    ..setIconResearch(SPELL_ICON)
    ..setIconTurnOff(SPELL_ICON)
    ..setHeroAbility(false)
    ..setItemAbility(false)
    ..setLevels(1)
    ..setHotkeyNormal("S")
    ..setName("Brambles")
    ..setDisableOtherAbilities(1, false)
    ..setFollowThroughTime(1, 0)
    ..setCastingTime(1, 0)
    ..setTooltipNormal(1, TOOLTIP_NORM)
    ..setTooltipNormalExtended(1, TOOLTIP_EXT)
    ..setBaseOrderID(1, "blackarrowoff")
    ..setOrderStringUseTurnOn("blackarrowoff")
    ..setOrderStringActivate("blackarrowoff")
    ..setOrderStringDeactivate("blackarrowoff")
    ..setOrderStringTurnOff("blackarrowoff")
    ..setOptions(1, 1)
    ..setCooldown(1, COOLDOWN)
    ..setManaCost(1, MANACOST)
    ..setTargetType(1, 3)
    ..setCastRange(1, RANGE)

class BramblesInstance
    unit ownerUnit
    player owner
    angle ang
    vec2 startPos
    bool isOvercharged
    LinkedList<unit> rootDummies = null
    LinkedList<effect> rootEffects = null
    CallbackPeriodic effectLoop = null

    construct(unit ownerUnit, vec2 pos, angle ang, bool isOvercharged)
        this.ownerUnit = ownerUnit
        this.owner = ownerUnit.getOwner()
        this.ang = ang
        this.startPos = pos
        this.rootDummies = new LinkedList<unit>()
        this.rootEffects = new LinkedList<effect>()
        this.isOvercharged = isOvercharged
        startPropagation()

    function startPropagation()
        int rootCount = (RANGE / (EFFECT_AOE*0.75)).ceil()
        real rootRange = RANGE / rootCount
        //Root creation
        doPeriodicallyCounted(ROOT_CREATION_PERIOD, rootCount) cb ->
            let rootPos = startPos.polarOffset(this.ang, rootRange * (rootEffects.size()+1))
            rootDummies.push(createRootDummy(rootPos, angle(0)))
            rootEffects.push(createRootEffect(rootPos, angle(GetRandomReal(-bj_PI, bj_PI))))

        startEffectLoop()
        doAfter(DURATION) ->
            destroy this

    function startEffectLoop()
        effectLoop = doPeriodically(UPDATE_LOOP_INTERVAL) cb ->

            //Linkedlist to prevent double damaging units
            LinkedList<unit> loopDamagedTargets = new LinkedList<unit>()

            for root in rootEffects
                let rootPos = root.getPos()
                forUnitsInRange(rootPos, EFFECT_AOE) u ->
                    if isValidTarget(u) and not loopDamagedTargets.has(u)
                        new DummyCaster().castTarget(owner, DUMMY_SLOW_SPELL_ID, 1, Orders.slow, u)
                        ownerUnit.damageTarget(u, DAMAGE_PER_SECOND*UPDATE_LOOP_INTERVAL, ATTACK_TYPE_NORMAL)
                        loopDamagedTargets.push(u)

            destroy loopDamagedTargets

    function createRootEffect(vec2 pos, angle ang) returns effect
        let fx = addEffect(ROOTS_EFFECT_PATH, pos.withTerrainZ(-70))
        fx.setRoll(ang)
        fx.setScale(2.4)
        return fx

    function createRootDummy(vec2 pos, angle ang) returns unit
        let dummy = DummyRecycler.get(pos, ang)
        dummy.setOwner(owner, false)
        dummy.addAbility(DUMMY_VISION_BONUS_ID)
        dummy.setAbilityLevel(DUMMY_VISION_BONUS_ID, 1)
        return dummy

    function cleanupDummy(unit dummy)
        dummy.setOwner(DUMMY_PLAYER, false)
        dummy.setPos(boundMax)
        DummyRecycler.recycle(dummy)

    function isValidTarget(unit target) returns bool
        return target.getOwner().isEnemyOf(owner) and not target.isInvulnerable() and not target.isType(UNIT_TYPE_FLYING) and target.isAlive() and not target.isHidden()

    ondestroy
        for dummy in rootDummies
            cleanupDummy(dummy)
        destroy rootDummies

        for fx in rootEffects
            fx.destr()
        destroy rootEffects

        destroy effectLoop

function onCast()
    let caster = GetSpellAbilityUnit()
    let casterPos = caster.getPos()
    let targetX = GetSpellTargetX()
    let targetY = GetSpellTargetY()
    let targetPos = vec2(targetX, targetY)
    let targetAngle = casterPos.angleTo(targetPos)
    let isOverCharged = consumeOvercharge(caster)
    new BramblesInstance(caster, caster.getPos(), targetAngle, isOverCharged)




init
    registerSpellEffectEvent(ABILITY_ID, () -> onCast())

    registerCommandAll("brambles") (triggerPlayer, args) ->
        if (gameConfig.isTestModeEnabled())
            printTimedToPlayer("Added brambles to any selected heroes", 5., triggerPlayer)
            forUnitsSelected(triggerPlayer) u ->
                if (u.isType(UNIT_TYPE_HERO))
                    u.addAbility(ABILITY_ID)
        else
            printTimedToPlayer("Requires test mode!", 5., triggerPlayer)